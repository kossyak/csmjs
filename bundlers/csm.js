var o={context:[],actions:{},events:{},create(t){this.context=t.context||[],this.actions=t.state,this.emit("_create",{...t}),this.update()},destroy(){this.context=[],this.actions={},this.emit("_destroy",this.context)},off(){this.events={}},value(t){return t?Array.isArray(t)?t:[t]:[]},action(t){let e=this.actions[t];e&&(this.context.includes(t)||this.context.push(t),this.push(e),this.delete(e),this.set(e),this.update(t))},set(t){t.set&&(this.context=this.value(t.set))},push(t){t.push&&this.value(t.push).forEach(e=>{this.context.includes(e)||this.context.push(e)})},delete(t){let e=[...this.value(t.delete),...this.value(t.pop)];if(e.length){let s=new Set(e);this.context=this.context.filter(i=>!s.has(i))}},tabu(t){if(t.tabu)return this.value(t.tabu).some(e=>this.context.includes(e))},update(t){let e=[];for(let[s,i]of Object.entries(this.actions))if(!this.tabu(i)){let n=0,h=[...this.value(i.pop),...this.value(i.permit)];if(h.length){for(let c of h)this.context.includes(c)&&n++;h.length===n&&e.push(s)}else e.push(s)}e.forEach(s=>this.emit(s,this.context)),this.emit("_change",{actions:e,trigger:t,context:this.context})},emit(t,e){if(!this.events[t])return;let s=this.events[t];for(let i of s)i(e)},on(t,e){this.events[t]||(this.events[t]=new Set);let s=this.events[t];return s.add(e),()=>{s.delete(e),s.size===0&&delete this.events[t]}}};export{o as default};
